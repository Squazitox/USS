<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fable.IcoMoonProvider</name></assembly>
<members>
<member name="T:ProviderImplementation.ProvidedTypes.AssemblyCompiler">
<summary>
 Implements System.Reflection.Assembly backed by ILModuleReader over generated bytes 
</summary>
</member>
<member name="F:ProviderImplementation.ProvidedTypes.ProvidedTypesContext.varTableFwd">
<summary>
 When translating quotations, Expr.Var&apos;s are translated to new variable respecting reference equality.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypesContext.ConvertSourceTypeToTarget(System.Type)">
<summary>
 Gets the equivalent target type
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypesContext.ConvertSourceMethodRefToTarget(System.Reflection.MethodInfo)">
<summary>
 Gets the equivalent target method
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypesContext.ConvertSourceConstructorRefToTarget(System.Reflection.ConstructorInfo)">
<summary>
 Gets the equivalent target constructor
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.ProvidedTypesContext">
<summary>
 A cross-targeting type provider must ultimately provide quotations and reflection objects w.r.t.
 the type binding context for the target assembly reference set.

 To make building a cross-targeting type provider palatable, the type provider is written w.r.t. to
 homogeneous quotations and reflection objects referring to a copy of the target runtime constructs held
 in the design-time assembly itself.   These are then systematically remapped (replaced/translated) to the
 corresponding reflection objects in the target assembly reference set.

 The ProvidedTypesContext acts as a way of creating provided objects where the replacement is automatically and
 systematically applied.
 Represents the type binding context for the type provider based on the set of assemblies
 referenced by the compilation.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.QuotationSimplifier">
<summary>
 the target model, i.e. before it is handed to the F# compiler (for erasing type providers) or 
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.TargetAssembly">
<summary>
 Implements System.Reflection.Assembly backed by .NET metadata provided by an ILModuleReader
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.TargetTypeDefinition">
<summary>
 Clones namespaces, type providers, types and members provided by tp, renaming namespace nsp1 into namespace nsp2.
 Makes a type definition read from a binary available as a System.Type. Not all methods are implemented.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.TargetGenericParam">
<summary>
 Convert an ILGenericParameterDef read from a binary to a System.Type.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.TypeSymbol">
<summary>
 Represents an array or other symbolic type involving a provided type as the argument.
 See the type provider spec for the methods that must be implemented.
 Note that the type provider specification does not require us to implement pointer-equality for provided types.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.TypeSymbolKind">
<summary>
 Represents the type constructor in a provided symbol type.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.FieldSymbol">
<summary>
 Represents a field in an instantiated type
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.EventSymbol">
<summary>
 Represents an event in an instantiated type
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.PropertySymbol">
<summary>
 Represents a property in an instantiated type
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.MethodSymbol">
<summary>
 Represents a method in an instantiated type
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.ConstructorSymbol">
<summary>
 Represents a constructor in an instantiated type
</summary>
</member>
<member name="F:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition.membersQueue">
<summary>
 Represents delayed members, as yet uncomputed
</summary>
</member>
<member name="F:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition.members">
<summary>
 Represents the evaluated members so far
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition.GetStaticParametersInternal">
<summary>
 Get ParameterInfo[] for the parametric type parameters 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition.DefineStaticParameters(Microsoft.FSharp.Collections.FSharpList{ProviderImplementation.ProvidedTypes.ProvidedStaticParameter},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Object[],ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition}})">
<summary>
 Abstract a type to a parametric-type. Requires &quot;formal parameters&quot; and &quot;instantiation function&quot;.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition.ApplyStaticArguments(System.String,System.Object[])">
<summary>
 Instantiate parametric type
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.ProvidedTypeDefinition">
<summary>
 backingDataSource is a set of functions to fetch backing data for the ProvidedTypeDefinition,
 and allows us to reuse this type for both target and source models, even when the
 source model is being incrementally updates by further .AddMember calls
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedProperty.#ctor(System.String,System.Type,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{ProviderImplementation.ProvidedTypes.ProvidedParameter}})">
<summary>
 The public constructor for the design-time/source model
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedMethod.GetStaticParametersInternal">
<summary>
 Get ParameterInfo[] for the parametric type parameters
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedMethod.DefineStaticParameters(Microsoft.FSharp.Collections.FSharpList{ProviderImplementation.ProvidedTypes.ProvidedStaticParameter},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Object[],ProviderImplementation.ProvidedTypes.ProvidedMethod}})">
<summary>
 Abstract a type to a parametric-type. Requires &quot;formal parameters&quot; and &quot;instantiation function&quot;.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedMethod.ApplyStaticArguments(System.String,System.Object[])">
<summary>
 Instantiate parametric method
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.ProvidedMethod.#ctor(System.String,Microsoft.FSharp.Collections.FSharpList{ProviderImplementation.ProvidedTypes.ProvidedParameter},System.Type,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 The public constructor for the design-time/source model
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.ProvidedTypeSymbol.FullName">
<summary>
 Substitute types for type variables.
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.ProvidedTypeSymbol.DeclaringType">
<summary>
 Although not strictly required by the type provider specification, this is required when doing basic operations like FullName on
 .NET symbolic types made from this type, e.g. when building Nullable&lt;SomeProvidedType[]&gt;.FullName
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.ProvidedTypeSymbol">
<summary>
 Represents an array or other symbolic type involving a provided type as the argument.
 See the type provider spec for the methods that must be implemented.
 Note that the type provider specification does not require us to implement pointer-equality for provided types.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.ProvidedTypeSymbolKind">
<summary>
 Represents the type constructor in a provided symbol type.
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.CodeBuffer.seh">
<summary>
 data for exception handling clauses 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.CodeBuffer.reqdStringFixupsInMethod">
<summary>
 code loc to fixup in code buffer 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.CodeBuffer.reqdBrFixups">
<summary>
 (instruction; optional short form); start of instr in code buffer; code loc for the end of the instruction the fixup resides in ; where is the destination of the fixup 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.cenv.tables">
<summary>
 The following are all used to generate unique items in the output 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.cenv.trefCache">
<summary>
 Caches
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.cenv.resources">
<summary>
 Raw resource data, to go into the data section 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.cenv.data">
<summary>
 Raw data, to go into the data section 
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.BinaryWriter.cenv.requiredStringFixups">
<summary>
 References to strings in codestreams: offset of code and a (fixup-location , string token) list) 
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.BinaryWriter.FieldDefKey">
<summary>
 We use this key type to help find ILFieldDefs for FieldRefs
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.BinaryWriter.MethodDefKey">
<summary>
 We use this key type to help find ILMethodDefs for MethodRefs 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.MetadataTable`1.SetRowsOfTable(`0[])">
<summary>
 This is only used in one special place - see further below. 
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.BinaryWriter.UnsharedRow">
<summary>
 Unshared rows are used for definitional tables where elements do not need to be made unique
 e.g. ILMethodDef and ILTypeDef. Most tables are like this. We don&apos;t precompute a 
 hash code for these rows, and indeed the GetHashCode and Equals should not be needed.
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.BinaryWriter.SharedRow">
<summary>
 This is the representation of shared rows is used for most shared row types.
 Rows ILAssemblyRef and ILMethodRef are very common and are given their own
 representations.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.GenTypeDefPass4(Microsoft.FSharp.Collections.FSharpList{System.String},ProviderImplementation.ProvidedTypes.BinaryWriter.cenv,ProviderImplementation.ProvidedTypes.AssemblyReader.ILTypeDef)">
<summary>
 ILTypeDef --&gt; generate generic params on ILMethodDef: ensures
 GenericParam table is built sorted by owner.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.GenEventAsEventRow(ProviderImplementation.ProvidedTypes.BinaryWriter.cenv,ProviderImplementation.ProvidedTypes.BinaryWriter.ILTypeWriterEnv,ProviderImplementation.ProvidedTypes.AssemblyReader.ILEventDef)">
<summary>
 ILEventDef --&gt; Event Row + MethodSemantics entries
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.GenPropertyPass3(ProviderImplementation.ProvidedTypes.BinaryWriter.cenv,ProviderImplementation.ProvidedTypes.BinaryWriter.ILTypeWriterEnv,ProviderImplementation.ProvidedTypes.AssemblyReader.ILPropertyDef)">
<summary>
 ILPropertyDef --&gt; Property Row + MethodSemantics entries
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.MemberRefRow(ProviderImplementation.ProvidedTypes.BinaryWriter.RowElement,System.Int32,System.Int32)">
<summary>
 Special representation the computes the hash more efficiently
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.AssemblyRefRow(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 Special representation: Note, only hashing by name
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.SimpleIndex(ProviderImplementation.ProvidedTypes.AssemblyReader.ILTableName,System.Int32)">
<summary>
 pos. in some table 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.StringE(System.Int32)">
<summary>
 pos. in string array 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.Blob(System.Int32)">
<summary>
 pos. in blob array 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.Guid(System.Int32)">
<summary>
 pos. in guid array 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.Data(System.Int32,System.Boolean)">
<summary>
 Index into cenv.data or cenv.resources.  Gets fixed up later once we known an overall
 location for the data section.  flag indicates if offset is relative to cenv.resources. 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.checkFixup32(System.Byte[],System.Int32,System.Int32)">
<summary>
 Check that the data held at a fixup is some special magic value, as a sanity check
 to ensure the fixup is being placed at a ood location.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.align(System.Int32,System.Int32)">
<summary>
 Alignment and padding
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.BinaryWriter.Codebuf.emitInstrCode(ProviderImplementation.ProvidedTypes.BinaryWriter.CodeBuffer,System.Int32)">
<summary>
 Emit the code for an instruction
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.AssemblyReader.ILLocalDebugMapping">
<summary>
 Indicates that a particular local variable has a particular source 
 language name within a given set of ranges. This does not effect local 
 variable numbering, which is global over the whole method. 
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.AssemblyReader.ILCallingConvStatics">
<summary>
 Static storage to amortize the allocation of ILCallingConv.Instance and ILCallingConv.Static
</summary>
</member>
<member name="T:ProviderImplementation.ProvidedTypes.AssemblyReader.ILArgConvention">
<summary>
 Calling conventions.  These are used in method pointer types.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.AssemblyReader.Reader.encodeCustomAttrPrimValue(System.Object)">
<summary>
 Given a custom attribute element, encode it to a binary representation according to the rules in Ecma 335 Partition II.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.AssemblyReader.Reader.encodeCustomAttrElemTypeForObject(System.Object)">
<summary>
 Given a custom attribute element, work out the type of the .NET argument for that element.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.AssemblyReader.Constants.ByteBuffer.Z32Size(System.Int32)">
<summary>
 Z32 = compressed unsigned integer 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.AssemblyReader.Constants.ByteBuffer.EmitZ32(System.Int32)">
<summary>
 Emit int32 as compressed unsigned integer
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.AssemblyReader.ILTableNames.sortedTableInfo">
<summary>
 Which tables are sorted and by which column. 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Misc.mkXmlDocCustomAttributeDataLazy(System.Lazy{System.String})">
<summary>
 This makes an xml doc attribute w.r.t. an amortized computation of an xml doc string.
 It is important that the text of the xml doc only get forced when poking on the ConstructorArguments
 for the CustomAttributeData object.
</summary>
</member>
<member name="P:ProviderImplementation.ProvidedTypes.Utils.emptyAttributes">
<summary>
 Internal code of .NET expects the obj[] returned by GetCustomAttributes to be an Attribute[] even in the case of empty arrays
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Utils.getAttributeFlagsImpl(System.Type)">
<summary>
 General implementation of .GetAttributeFlags logic for System.Type over symbol types 
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Utils.isSubclassOf(System.Type,System.Type)">
<summary>
 General implementation of .IsSubclassOf logic for System.Type, regardless of specific implementation, with 
 an added hack to make the types usable with the FSharp.Core quotations implementation
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Utils.isAssignableFrom(System.Type,System.Type)">
<summary>
 General implementation of .IsAssignableFrom logic for System.Type, regardless of specific implementation
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Utils.eqTypeObj(System.Type,System.Object)">
<summary>
 General implementation of .Equals(obj) logic for System.Type over symbol types. You can use this with other types too.
</summary>
</member>
<member name="M:ProviderImplementation.ProvidedTypes.Utils.eqTypes(System.Type,System.Type)">
<summary>
 General implementation of .Equals(Type) logic for System.Type over symbol types. You can use this with other types too.
</summary>
</member>
</members>
</doc>
